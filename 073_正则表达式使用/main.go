package main

import (
	"fmt"
	"regexp"
)

/*
	正则表达式的使用：
	使用 regexp (regular expression) 标准包
*/

func main() {

	str := "abc a7c mfc cat 8ca azc cba ga4c8"

	//1. 解析、编译正则表达式，将表达式转换成go语言能识别的格式
	//参数：正则表达式字串。建议使用反引号``
	//返回值：编译后的结构体。解析失败时会产生panic错误
	ret := regexp.MustCompile(`a.c`)

	//2. 根据解析好的规则从指定字符串中删选信息，返回二维切片
	//参数1：待解析的字符串
	//参数2：匹配的次数。通常传-1，表示匹配所有
	//返回值：返回成功匹配的[][]string
	//		[[string1 string2][string1 string2][string1 string2] ]
	//		string1(下标0): 表示带有匹配参考项的全部字串
	//		string2(下标1): 表示去除匹配参考项后的字串
	subStr := ret.FindAllStringSubmatch(str, -1)
	fmt.Println(subStr)

	//
	//匹配所有小数
	str = "3.14 123.123 .68 haha 1.0 abc 7. ab.3 66.6 123."
	ret = regexp.MustCompile(`[0-9]+\.[0-9]+`)
	subStr = ret.FindAllStringSubmatch(str, -1)
	fmt.Println(subStr)

}

/*

正则表达式语法：


linux查找文件匹配字符串的命令：

	egrep 'xxx' filename


字符类：

	.	匹配任意一个字符（不包含\n）
		abc.可匹配adcd、abc9等...

	[]	匹配[]内任意一个字符
		[abc]d可匹配ad、bd或cd...

	-	在[]表示字符范围
		[0-9a-fA-F]可匹配一位十六进制数

	^	位于[]内的开头，匹配除[]内字符之外的任意一个字符
		[^xy]匹配除xy之外的任意一字符，因此[^xy]1可匹配a1、b1但不匹配x1、y1


数量限定符：


	？	匹配它前面的单元0次或1次
		[0-9]?\.[0-9]匹配0.0、2.3、.5等...（.在正则表达式中属于特殊字符，因此需要\转义）

	+	匹配它前面的单元1次或N次
		[a-zA-Z0-9_.-]+@[][a-zA-Z0-9_.-]+\.[a-zA-Z0-9_.-]+匹配邮件地址

	*	匹配它前面的单元0次或N次
		[0-9][0-9]*匹配至少一位数字，等价于[0-9]+

	{N}	匹配它前面的单元N次
		[1-9][0-9]{2}匹配从100到999的整数

	{N,}	匹配它前面的单元至少N次
		[1-9][0-9]{2,}匹配三位以上（含三位）的整数

	{N,M}	匹配它前面的单元至少N次，最多M次
		[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}匹配IP地址



位置限定符：

	^	指定该字符后面的单元为起始，位于[]外

	$	指定该字符前面的单元为结尾


其他数字符：

	\	转义字符
		特殊字符.写成\.或\写成\\作为普通字符

	()	将表达式的一部分组成一个单元，可对整个单元使用数量限定符
		([0-9]{1,3}\.){3}[0-9]{1,3}匹配IP地址

	|	连接两个子表达式，表示或的关系
		h(is|im)匹配his或him



-----------------------------------------------------------

正则表达式筛选带有匹配参考项的字符串时：可快速使用表达式 (?s:(.*?)) 放到起始参考项和结束参考项之间


	(?s) 	正则表达式的模式修饰符。即Singleline(单行模式)。表示更改.的含义。使它与每一个字符匹配（包括换行符\n）。
	(.*?) 	单元分组。“.”匹配任意字符。“*?”表重复>=0次匹配。包含’\n’
			将(?s:(.*?))元组放置于某一特征字串中，可以提取这一特征字串包裹的内容。


*/
